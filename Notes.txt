    public function index() // Here we are doing crud opperations
    {
        // the all method return a collection
        # $blog = Blog::all();

        // The find method takes a parameter which is the identifier
        # $blog = Blog::find(2);
        # returns the first value
        # $blog = Blog::first();

        // BTW these are eloquent queries
        # $blog = Blog::all();

        // Raw queries use DB instance initialization
        # $blog = DB::select('SELECT * FROM blogs'); //->get()

        // ADDING DATA TO THE DATABASE
        # $blog = new Blog(); // This creates an instance of our model
        # $blog -> title = '2 this is a new title';
        # $blog -> body = '2 this is a new body';
        # $blog -> status = 0;
        # $blog -> save();

        // UPDATING DATA IN THE DATABASE
        # $blog = Blog::find(1);
        # //dd($blog);
        # $blog -> title = 'this is a new title and its awesome';
        # $blog -> body = 'this is a new body its just as awesome';
        # $blog -> status = 1;
        # $blog -> save();

        // FINDING VALUES FROM THE DATABASE
        # $blog = Blog::where('status', '=', 1)->where('id', '=', 2)->get();

        // HOW TO CHAIN MULTIPLE WHERE CONDITIONS (Using Arrays)
        // Note array uses the equal and arrow
        #$blog = Blog::where(['status' => 0, 'id' =>3])->get();

        // DELETE DATA
        # $blog = Blog::find(2);
        # $blog->delete();
        // findOrFail method is case sensitive
        # $blog = Blog::findOrFail(2); // to return users to the 404 page incase the data doesnt exist
        # $blog->delete();

        dd($blog); // dd means dump and die. debugging tool that output the value of the given variable then immediately stop the execution of the script.
    }

Relationships
    public function index()
    {
        // ONE TO ONE RELATIONSHIP
        #==========================
        // Return the object with its relation object (belongsTo)
        # $blog = Blog::all();
        # $category = $blog->category;
        # return $blog;

        // Fetching data with its categories
        // NOTE : all() -> is a static method and cannot be used in a chaining way
        # $blog = Blog::with('category')->get();
        # return $blog;

        // Fetching data with its categories
        // NOTE : all() -> is a static method and cannot be used in a chaining way
        # $blog = Blog::with('category')->get();
        # return $blog;

        // Running a loop on the collection maybe we want only the titles of the blog
        // This is a continuation of our 1 to 1 relationship
        # $blogs = Blog::with('category')->get();
        # foreach($blogs as $blog)
        # {
        #     echo $blog->title.' & '.$blog->category->name;
        #     echo '</br>';
        # }

        // ONE TO MANY RELATIONSHIP
        #==========================
        # $category = Category::find(1);
        # return $category->blogs;
    }

Form Handling
        public function store(Request $request)
    {
        // Validate uses a key (column) and a value (constraint) pair in the array
         $request->validate([
            // 'category' =>'required|intager' // You can use a pipe or an array
            'category' => ['required', 'integer'], // The array looks more convinien
            'title' => ['required', 'max:255', 'min:2'], // When it comes to varchar you always have to add the max value
            'body' => ['required'],
            'status' => ['required', 'boolean'],
            'image' => ['required', 'image', 'max:3000']
         ]);

         // upload file
         $imagePath = $this->uploadFile($request);

         // Store Data
         $blog = new Blog();
         $blog->category_id = $request->category; // remember category is the name of the name for the select field
         $blog->image = $imagePath;
         $blog->title = $request->title;
         $blog->body = $request->body;
         $blog->status = $request->status;
         $blog->save();

         session()->flash('success', 'Your Blog has been created successfully!'); // flash only stays on one reload (has key and value)
         return redirect()->back();
    }

    public function uploadFile(Request $request)
    {
        if($request->hasFile('image')){
            $image = $request->file('image'); // We now have access to the image
            $imageName = $image->getClientOriginalName(); // getClientOriginalName() will extract the name of the file with its extention
            $image->move(public_path('uploads'), $imageName); // move takes the directory and file name, public_path('uploads') tinker will access the local path
            return $imagePath = 'uploads/'.$imageName; // we only need to store the child path in the database not the whole local path
         }
    }

Middleware
    protected $routeMiddleware = [
        'auth.check' => \App\Http\Middleware\AdminCheck::class,
    ];

    class AdminCheck
    {
        /**
        * Handle an incoming request.
        *
        * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
        */
        public function handle(Request $request, Closure $next): Response
        {
            $user = 1;

            if ($user != 1){
                return redirect()->route('home');
            }
            return $next($request);
        }
    }
